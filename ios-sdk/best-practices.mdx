---
title: "æœ€ä½³å®è·µ"
description: "SPAvatarKit SDK æ€§èƒ½ä¼˜åŒ–å’Œå¼€å‘å»ºè®®"
---

## æ€§èƒ½ä¼˜åŒ–

### å†…å­˜ç®¡ç†

<Warning>
æ­£ç¡®çš„å†…å­˜ç®¡ç†å¯¹äºæ•°å­—äººæ¸²æŸ“è‡³å…³é‡è¦ï¼Œä¸å½“çš„å†…å­˜ä½¿ç”¨å¯èƒ½å¯¼è‡´åº”ç”¨å´©æºƒæˆ–æ€§èƒ½é—®é¢˜ã€‚
</Warning>

#### ç”Ÿå‘½å‘¨æœŸç®¡ç†

```swift title="æ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†"
class AvatarViewController: UIViewController {
    private var renderer: AvatarRenderer?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupRenderer()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        // é¡µé¢å³å°†æ˜¾ç¤ºæ—¶å¯åŠ¨æ¸²æŸ“
        renderer?.start()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        // é¡µé¢å³å°†éšè—æ—¶åœæ­¢æ¸²æŸ“ä»¥èŠ‚çœèµ„æº
        renderer?.stop()
    }
    
    deinit {
        // ç¡®ä¿åœ¨å¯¹è±¡é”€æ¯æ—¶æ¸…ç†èµ„æº
        renderer?.stop()
        renderer = nil
        print("AvatarViewController å·²é‡Šæ”¾")
    }
    
    private func setupRenderer() {
        renderer = AvatarRenderer(frame: view.bounds)
        renderer?.delegate = self
        view.addSubview(renderer!)
    }
}
```

<Check>
éµå¾ªè¿™ç§æ¨¡å¼å¯ä»¥ç¡®ä¿æ¸²æŸ“å™¨åœ¨é€‚å½“çš„æ—¶æœºå¯åŠ¨å’Œåœæ­¢ï¼Œé¿å…ä¸å¿…è¦çš„èµ„æºæ¶ˆè€—ã€‚
</Check>

### èµ„æºé¢„åŠ è½½

<Tip>
é¢„åŠ è½½å¸¸ç”¨æ¨¡å‹å¯ä»¥æ˜¾è‘—æå‡ç”¨æˆ·ä½“éªŒï¼Œå‡å°‘é¦–æ¬¡åŠ è½½æ—¶é—´ã€‚
</Tip>

#### æ™ºèƒ½é¢„åŠ è½½ç­–ç•¥

```swift title="æ™ºèƒ½é¢„åŠ è½½å®ç°"
class ModelPreloader {
    private var preloadedModels: Set<URL> = []
    private let maxConcurrentPreloads = 2
    private var currentPreloads = 0
    
    func preloadModels() {
        let modelURLs = [
            URL(string: "https://cdn.example.com/model1.avatar")!,
            URL(string: "https://cdn.example.com/model2.avatar")!,
            URL(string: "https://cdn.example.com/model3.avatar")!
        ]
        
        // æŒ‰ä¼˜å…ˆçº§é¢„åŠ è½½
        preloadWithPriority(modelURLs)
    }
    
    private func preloadWithPriority(_ urls: [URL]) {
        for url in urls {
            guard !preloadedModels.contains(url),
                  currentPreloads < maxConcurrentPreloads else {
                continue
            }
            
            currentPreloads += 1
            AvatarSDK.preloadModel(url) { [weak self] result in
                defer { self?.currentPreloads -= 1 }
                
                switch result {
                case .success:
                    print("æ¨¡å‹é¢„åŠ è½½æˆåŠŸ: \(url.lastPathComponent)")
                    self?.preloadedModels.insert(url)
                case .failure(let error):
                    print("æ¨¡å‹é¢„åŠ è½½å¤±è´¥: \(error)")
                }
            }
        }
    }
    
    func isModelPreloaded(_ url: URL) -> Bool {
        return preloadedModels.contains(url)
    }
}
```

#### åŸºäºä½¿ç”¨é¢‘ç‡çš„é¢„åŠ è½½

```swift title="åŸºäºä½¿ç”¨é¢‘ç‡çš„é¢„åŠ è½½"
class UsageBasedPreloader {
    private var modelUsageCount: [URL: Int] = [:]
    
    func recordModelUsage(_ url: URL) {
        modelUsageCount[url, default: 0] += 1
        
        // å½“ä½¿ç”¨æ¬¡æ•°è¾¾åˆ°é˜ˆå€¼æ—¶ï¼Œé¢„åŠ è½½ç›¸å…³æ¨¡å‹
        if modelUsageCount[url]! >= 3 {
            preloadRelatedModels(for: url)
        }
    }
    
    private func preloadRelatedModels(for url: URL) {
        // æ ¹æ®ä¸šåŠ¡é€»è¾‘é¢„åŠ è½½ç›¸å…³æ¨¡å‹
        let relatedModels = getRelatedModels(for: url)
        
        for relatedModel in relatedModels {
            AvatarSDK.preloadModel(relatedModel) { result in
                // å¤„ç†é¢„åŠ è½½ç»“æœ
            }
        }
    }
    
    private func getRelatedModels(for url: URL) -> [URL] {
        // å®ç°è·å–ç›¸å…³æ¨¡å‹çš„é€»è¾‘
        return []
    }
}
```

### æ¸²æŸ“è´¨é‡ä¼˜åŒ–

<Info>
æ ¹æ®è®¾å¤‡æ€§èƒ½å’Œå®æ—¶å¸§ç‡åŠ¨æ€è°ƒæ•´æ¸²æŸ“è´¨é‡ï¼Œå¯ä»¥åœ¨æ€§èƒ½å’Œè§†è§‰æ•ˆæœä¹‹é—´æ‰¾åˆ°æœ€ä½³å¹³è¡¡ã€‚
</Info>

#### è®¾å¤‡æ€§èƒ½æ£€æµ‹

```swift title="è®¾å¤‡æ€§èƒ½è¯„ä¼°"
class DevicePerformanceAnalyzer {
    enum PerformanceLevel {
        case low, medium, high
    }
    
    static func analyzePerformance() -> PerformanceLevel {
        let processorCount = ProcessInfo.processInfo.processorCount
        let physicalMemory = ProcessInfo.processInfo.physicalMemory
        let deviceType = UIDevice.current.userInterfaceIdiom
        
        // ç»¼åˆè¯„ä¼°è®¾å¤‡æ€§èƒ½
        if deviceType == .pad && processorCount >= 8 && physicalMemory >= 4_000_000_000 {
            return .high
        } else if processorCount >= 6 && physicalMemory >= 3_000_000_000 {
            return .medium
        } else {
            return .low
        }
    }
    
    static func recommendedQuality() -> RenderQuality {
        switch analyzePerformance() {
        case .high:
            return .high
        case .medium:
            return .medium
        case .low:
            return .low
        }
    }
}
```

#### è‡ªé€‚åº”è´¨é‡è°ƒæ•´

```swift title="è‡ªé€‚åº”è´¨é‡ç®¡ç†"
class AdaptiveQualityManager {
    private var renderer: AvatarRenderer
    private var fpsHistory: [Double] = []
    private let maxHistorySize = 10
    private var lastQualityAdjustment = Date()
    
    init(renderer: AvatarRenderer) {
        self.renderer = renderer
        setupInitialQuality()
    }
    
    private func setupInitialQuality() {
        renderer.quality = DevicePerformanceAnalyzer.recommendedQuality()
    }
    
    func handleFPSUpdate(_ fps: Double) {
        // è®°å½•å¸§ç‡å†å²
        fpsHistory.append(fps)
        if fpsHistory.count > maxHistorySize {
            fpsHistory.removeFirst()
        }
        
        // é¿å…é¢‘ç¹è°ƒæ•´
        guard Date().timeIntervalSince(lastQualityAdjustment) > 2.0 else { return }
        
        let averageFPS = fpsHistory.reduce(0, +) / Double(fpsHistory.count)
        adjustQualityBasedOnFPS(averageFPS)
    }
    
    private func adjustQualityBasedOnFPS(_ averageFPS: Double) {
        let currentQuality = renderer.quality
        
        switch currentQuality {
        case .high:
            if averageFPS < 25 {
                renderer.quality = .medium
                lastQualityAdjustment = Date()
                print("é™ä½æ¸²æŸ“è´¨é‡åˆ° mediumï¼Œå½“å‰å¹³å‡å¸§ç‡: \(averageFPS)")
            }
        case .medium:
            if averageFPS < 20 {
                renderer.quality = .low
                lastQualityAdjustment = Date()
                print("é™ä½æ¸²æŸ“è´¨é‡åˆ° lowï¼Œå½“å‰å¹³å‡å¸§ç‡: \(averageFPS)")
            } else if averageFPS > 45 {
                renderer.quality = .high
                lastQualityAdjustment = Date()
                print("æå‡æ¸²æŸ“è´¨é‡åˆ° highï¼Œå½“å‰å¹³å‡å¸§ç‡: \(averageFPS)")
            }
        case .low:
            if averageFPS > 35 {
                renderer.quality = .medium
                lastQualityAdjustment = Date()
                print("æå‡æ¸²æŸ“è´¨é‡åˆ° mediumï¼Œå½“å‰å¹³å‡å¸§ç‡: \(averageFPS)")
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
extension ViewController: AvatarRendererDelegate {
    func renderer(_ renderer: AvatarRenderer, didUpdateFPS fps: Double) {
        qualityManager.handleFPSUpdate(fps)
    }
}
```

## é”™è¯¯å¤„ç†

<Warning>
è‰¯å¥½çš„é”™è¯¯å¤„ç†ç­–ç•¥æ˜¯ç¡®ä¿åº”ç”¨ç¨³å®šæ€§å’Œç”¨æˆ·ä½“éªŒçš„å…³é”®ã€‚
</Warning>

### ä¼˜é›…é™çº§

å½“é‡åˆ°é”™è¯¯æ—¶ï¼Œåº”è¯¥æä¾›ä¼˜é›…çš„é™çº§æ–¹æ¡ˆï¼Œç¡®ä¿åº”ç”¨ç»§ç»­å¯ç”¨ã€‚

```swift title="é”™è¯¯å¤„ç†å’Œä¼˜é›…é™çº§"
class ErrorHandler {
    private var fallbackStrategies: [AvatarError: () -> Void] = [:]
    
    init() {
        setupFallbackStrategies()
    }
    
    private func setupFallbackStrategies() {
        fallbackStrategies[.networkError] = handleNetworkError
        fallbackStrategies[.modelLoadError] = handleModelLoadError
        fallbackStrategies[.renderError] = handleRenderError
    }
    
    func handleError(_ error: AvatarError, context: String = "") {
        // è®°å½•é”™è¯¯æ—¥å¿—
        logError(error, context: context)
        
        // æ‰§è¡Œå¯¹åº”çš„é™çº§ç­–ç•¥
        if let strategy = fallbackStrategies[error] {
            strategy()
        } else {
            handleGenericError(error)
        }
    }
    
    private func handleNetworkError() {
        // æ˜¾ç¤ºç½‘ç»œé”™è¯¯æç¤º
        showUserFriendlyAlert(
            title: "ç½‘ç»œè¿æ¥é—®é¢˜",
            message: "æ­£åœ¨å°è¯•ä½¿ç”¨ç¦»çº¿æ¨¡å¼"
        )
        
        // å°è¯•ä½¿ç”¨ç¼“å­˜çš„æ¨¡å‹
        loadCachedModel()
    }
    
    private func handleModelLoadError() {
        // æ˜¾ç¤ºæ¨¡å‹åŠ è½½é”™è¯¯
        showUserFriendlyAlert(
            title: "æ¨¡å‹åŠ è½½å¤±è´¥",
            message: "æ­£åœ¨åŠ è½½å¤‡ç”¨æ¨¡å‹"
        )
        
        // å›é€€åˆ°é»˜è®¤æ¨¡å‹
        loadDefaultModel()
    }
    
    private func handleRenderError() {
        // æ¸²æŸ“é”™è¯¯ï¼Œé™ä½è´¨é‡é‡è¯•
        showUserFriendlyAlert(
            title: "æ¸²æŸ“ä¼˜åŒ–ä¸­",
            message: "æ­£åœ¨è°ƒæ•´ç”»è´¨ä»¥æå‡æ€§èƒ½"
        )
        
        renderer.quality = .low
        renderer.retry()
    }
    
    private func handleGenericError(_ error: AvatarError) {
        showUserFriendlyAlert(
            title: "é‡åˆ°é—®é¢˜",
            message: "æˆ‘ä»¬æ­£åœ¨åŠªåŠ›è§£å†³ï¼Œè¯·ç¨åé‡è¯•"
        )
    }
    
    private func logError(_ error: AvatarError, context: String) {
        let errorInfo = [
            "error": error.localizedDescription,
            "context": context,
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        // å‘é€åˆ°åˆ†ææœåŠ¡
        Analytics.track("avatar_error", properties: errorInfo)
    }
}
```

<Tip>
ä¸ºç”¨æˆ·æä¾›æ¸…æ™°ã€å‹å¥½çš„é”™è¯¯ä¿¡æ¯ï¼Œé¿å…æŠ€æœ¯æœ¯è¯­ï¼Œå¹¶å§‹ç»ˆæä¾›è§£å†³æ–¹æ¡ˆæˆ–æ›¿ä»£æ–¹æ¡ˆã€‚
</Tip>

å®ç°å¤šçº§é™çº§ç­–ç•¥ï¼Œç¡®ä¿åº”ç”¨ç¨³å®šæ€§ã€‚

```swift
class RobustAvatarRenderer {
    private var primaryRenderer: AvatarRenderer?
    private var fallbackRenderer: AvatarRenderer?
    private var isUsingFallback = false
    
    func loadModel(_ url: URL) {
        do {
            try primaryRenderer?.load(model: url)
            isUsingFallback = false
        } catch {
            print("ä¸»æ¸²æŸ“å™¨åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¸²æŸ“å™¨")
            try? fallbackRenderer?.load(model: url)
            isUsingFallback = true
        }
    }
    
    func start() {
        if isUsingFallback {
            fallbackRenderer?.start()
        } else {
            primaryRenderer?.start()
        }
    }
}
```

### é‡è¯•æœºåˆ¶

<Info>
æ™ºèƒ½é‡è¯•æœºåˆ¶å¯ä»¥æœ‰æ•ˆå¤„ç†ç½‘ç»œæ³¢åŠ¨ã€ä¸´æ—¶æœåŠ¡ä¸å¯ç”¨ç­‰é—®é¢˜ï¼Œæå‡åº”ç”¨çš„å¥å£®æ€§ã€‚
</Info>

#### æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥

```swift title="æ™ºèƒ½é‡è¯•ç®¡ç†å™¨"
class RetryManager {
    private let maxRetries: Int
    private let baseDelay: TimeInterval
    private let maxDelay: TimeInterval
    private var retryCount = 0
    
    init(maxRetries: Int = 3, baseDelay: TimeInterval = 1.0, maxDelay: TimeInterval = 30.0) {
        self.maxRetries = maxRetries
        self.baseDelay = baseDelay
        self.maxDelay = maxDelay
    }
    
    func executeWithRetry<T>(
        operation: @escaping () async throws -> T,
        shouldRetry: @escaping (Error) -> Bool = { _ in true },
        onSuccess: @escaping (T) -> Void,
        onFailure: @escaping (Error) -> Void
    ) {
        Task {
            do {
                let result = try await operation()
                onSuccess(result)
                retryCount = 0 // é‡ç½®è®¡æ•°
            } catch {
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥é‡è¯•
                guard shouldRetry(error) && retryCount < maxRetries else {
                    onFailure(error)
                    retryCount = 0
                    return
                }
                
                retryCount += 1
                let delay = calculateDelay()
                
                print("æ“ä½œå¤±è´¥ï¼Œ\(delay)ç§’åè¿›è¡Œç¬¬\(retryCount)æ¬¡é‡è¯•")
                
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                executeWithRetry(
                    operation: operation,
                    shouldRetry: shouldRetry,
                    onSuccess: onSuccess,
                    onFailure: onFailure
                )
            }
        }
    }
    
    private func calculateDelay() -> TimeInterval {
        // æŒ‡æ•°é€€é¿ç®—æ³•ï¼ŒåŠ å…¥éšæœºæŠ–åŠ¨
        let exponentialDelay = baseDelay * pow(2.0, Double(retryCount - 1))
        let jitter = Double.random(in: 0.1...0.3) * exponentialDelay
        return min(exponentialDelay + jitter, maxDelay)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
class AvatarService {
    private let retryManager = RetryManager()
    
    func loadModel(url: URL) {
        retryManager.executeWithRetry(
            operation: {
                try await self.performModelLoad(url)
            },
            shouldRetry: { error in
                // åªå¯¹ç‰¹å®šé”™è¯¯è¿›è¡Œé‡è¯•
                if let avatarError = error as? AvatarError {
                    switch avatarError {
                    case .networkError, .serverError:
                        return true
                    case .invalidModel, .authenticationError:
                        return false
                    default:
                        return true
                    }
                }
                return true
            },
            onSuccess: { model in
                print("æ¨¡å‹åŠ è½½æˆåŠŸ")
                self.handleModelLoaded(model)
            },
            onFailure: { error in
                print("æ¨¡å‹åŠ è½½æœ€ç»ˆå¤±è´¥: \(error)")
                self.handleModelLoadFailure(error)
            }
        )
    }
    
    private func performModelLoad(_ url: URL) async throws -> AvatarModel {
        // å®é™…çš„æ¨¡å‹åŠ è½½é€»è¾‘
        return AvatarModel()
    }
}
```

<Check>
è¿™ç§é‡è¯•ç­–ç•¥åŒ…å«äº†æŒ‡æ•°é€€é¿ã€éšæœºæŠ–åŠ¨å’Œæ¡ä»¶é‡è¯•ï¼Œå¯ä»¥æœ‰æ•ˆé¿å…æœåŠ¡å™¨è¿‡è½½å¹¶æé«˜æˆåŠŸç‡ã€‚
</Check>

å®ç°æ™ºèƒ½é‡è¯•æœºåˆ¶å¤„ç†ä¸´æ—¶æ€§é”™è¯¯ã€‚

```swift
func loadModelWithRetry(_ url: URL, maxRetries: Int = 3) {
    var retryCount = 0
    
    func attemptLoad() {
        do {
            try renderer.load(model: url)
        } catch {
            retryCount += 1
            if retryCount < maxRetries {
                // æŒ‡æ•°é€€é¿é‡è¯•
                let delay = pow(2.0, Double(retryCount))
                DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                    attemptLoad()
                }
            } else {
                print("æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                showErrorAlert(error)
            }
        }
    }
    
    attemptLoad()
}
```

## ç”¨æˆ·ä½“éªŒ

<Info>
è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒè®¾è®¡å¯ä»¥æ˜¾è‘—æå‡ç”¨æˆ·æ»¡æ„åº¦å’Œåº”ç”¨çš„ä¸“ä¸šåº¦ã€‚
</Info>

### åŠ è½½çŠ¶æ€ç®¡ç†

<Tip>
æä¾›æ¸…æ™°ã€å®æ—¶çš„åŠ è½½çŠ¶æ€åé¦ˆï¼Œè®©ç”¨æˆ·äº†è§£å½“å‰è¿›åº¦å’Œé¢„æœŸç­‰å¾…æ—¶é—´ã€‚
</Tip>

#### å¢å¼ºçš„åŠ è½½è§†å›¾è®¾è®¡

```swift title="å¢å¼ºçš„åŠ è½½çŠ¶æ€ç®¡ç†"
class AvatarView: UIView {
    private let activityIndicator = UIActivityIndicatorView(style: .large)
    private let renderer = AvatarRenderer()
    private let statusLabel = UILabel()
    private let progressView = UIProgressView(progressViewStyle: .default)
    private let timeLabel = UILabel()
    private var startTime: Date?
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupUI()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupUI()
    }
    
    private func setupUI() {
        backgroundColor = UIColor.systemBackground
        
        // è®¾ç½®åŠ è½½æŒ‡ç¤ºå™¨
        addSubview(activityIndicator)
        activityIndicator.translatesAutoresizingMaskIntoConstraints = false
        activityIndicator.hidesWhenStopped = true
        activityIndicator.color = .systemBlue
        
        // è®¾ç½®è¿›åº¦æ¡
        addSubview(progressView)
        progressView.translatesAutoresizingMaskIntoConstraints = false
        progressView.progressTintColor = .systemBlue
        progressView.trackTintColor = .systemGray5
        progressView.isHidden = true
        
        // è®¾ç½®çŠ¶æ€æ ‡ç­¾
        addSubview(statusLabel)
        statusLabel.translatesAutoresizingMaskIntoConstraints = false
        statusLabel.textAlignment = .center
        statusLabel.textColor = .label
        statusLabel.font = .systemFont(ofSize: 16, weight: .medium)
        statusLabel.numberOfLines = 0
        
        // è®¾ç½®æ—¶é—´æ ‡ç­¾
        addSubview(timeLabel)
        timeLabel.translatesAutoresizingMaskIntoConstraints = false
        timeLabel.textAlignment = .center
        timeLabel.textColor = .secondaryLabel
        timeLabel.font = .systemFont(ofSize: 12)
        
        setupConstraints()
    }
    
    private func setupConstraints() {
        NSLayoutConstraint.activate([
            activityIndicator.centerXAnchor.constraint(equalTo: centerXAnchor),
            activityIndicator.centerYAnchor.constraint(equalTo: centerYAnchor, constant: -40),
            
            progressView.centerXAnchor.constraint(equalTo: centerXAnchor),
            progressView.centerYAnchor.constraint(equalTo: centerYAnchor, constant: -20),
            progressView.widthAnchor.constraint(equalTo: widthAnchor, multiplier: 0.7),
            
            statusLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            statusLabel.topAnchor.constraint(equalTo: activityIndicator.bottomAnchor, constant: 20),
            statusLabel.leadingAnchor.constraint(greaterThanOrEqualTo: leadingAnchor, constant: 20),
            statusLabel.trailingAnchor.constraint(lessThanOrEqualTo: trailingAnchor, constant: -20),
            
            timeLabel.centerXAnchor.constraint(equalTo: centerXAnchor),
            timeLabel.topAnchor.constraint(equalTo: statusLabel.bottomAnchor, constant: 8)
        ])
    }
    
    func loadModel(_ url: URL) {
        startTime = Date()
        activityIndicator.startAnimating()
        progressView.isHidden = false
        progressView.progress = 0.0
        updateStatus("æ­£åœ¨è¿æ¥æœåŠ¡å™¨...", progress: 0.1)
        
        do {
            try renderer.load(model: url)
            renderer.delegate = self
        } catch {
            handleLoadingError(error)
        }
    }
    
    private func updateStatus(_ message: String, progress: Float? = nil) {
        DispatchQueue.main.async {
            self.statusLabel.text = message
            
            if let progress = progress {
                self.progressView.setProgress(progress, animated: true)
            }
            
            // æ›´æ–°æ—¶é—´æ˜¾ç¤º
            if let startTime = self.startTime {
                let elapsed = Date().timeIntervalSince(startTime)
                self.timeLabel.text = String(format: "å·²ç”¨æ—¶: %.1fç§’", elapsed)
            }
        }
    }
    
    private func handleLoadingError(_ error: Error) {
        DispatchQueue.main.async {
            self.activityIndicator.stopAnimating()
            self.progressView.isHidden = true
            self.statusLabel.text = "åŠ è½½å¤±è´¥"
            self.statusLabel.textColor = .systemRed
            self.showError(error)
        }
    }
    
    private func handleLoadingSuccess() {
        DispatchQueue.main.async {
            self.activityIndicator.stopAnimating()
            self.progressView.progress = 1.0
            self.statusLabel.text = "åŠ è½½å®Œæˆ"
            self.statusLabel.textColor = .systemGreen
            
            // å»¶è¿Ÿéšè—åŠ è½½ç•Œé¢
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                self.hideLoadingUI()
            }
        }
    }
    
    private func hideLoadingUI() {
        UIView.animate(withDuration: 0.3) {
            self.progressView.alpha = 0
            self.statusLabel.alpha = 0
            self.timeLabel.alpha = 0
        } completion: { _ in
            self.progressView.isHidden = true
            self.statusLabel.isHidden = true
            self.timeLabel.isHidden = true
        }
    }
    
    private func showError(_ error: Error) {
        let alert = UIAlertController(
            title: "åŠ è½½å¤±è´¥",
            message: error.localizedDescription,
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "é‡è¯•", style: .default) { _ in
            // é‡è¯•é€»è¾‘
        })
        
        alert.addAction(UIAlertAction(title: "å–æ¶ˆ", style: .cancel))
        
        // è·å–å½“å‰è§†å›¾æ§åˆ¶å™¨å¹¶æ˜¾ç¤ºè­¦å‘Š
        if let viewController = self.findViewController() {
            viewController.present(alert, animated: true)
        }
    }
}

extension AvatarView: AvatarRendererDelegate {
    func renderer(_ renderer: AvatarRenderer, didLoadModel url: URL) {
        updateStatus("æ¨¡å‹åŠ è½½å®Œæˆï¼Œæ­£åœ¨åˆå§‹åŒ–...", progress: 0.9)
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.handleLoadingSuccess()
            self.renderer.start()
        }
    }
    
    func renderer(_ renderer: AvatarRenderer, didUpdateProgress progress: Float) {
        let message: String
        switch progress {
        case 0.0..<0.3:
            message = "æ­£åœ¨ä¸‹è½½æ¨¡å‹æ•°æ®..."
        case 0.3..<0.6:
            message = "æ­£åœ¨è§£ææ¨¡å‹æ–‡ä»¶..."
        case 0.6..<0.9:
            message = "æ­£åœ¨åˆå§‹åŒ–æ¸²æŸ“å¼•æ“..."
        default:
            message = "å³å°†å®Œæˆ..."
        }
        
        updateStatus(message, progress: progress)
    }
    
    func renderer(_ renderer: AvatarRenderer, didFail error: AvatarError) {
        handleLoadingError(error)
    }
}

// UIView æ‰©å±•ï¼Œç”¨äºæŸ¥æ‰¾çˆ¶è§†å›¾æ§åˆ¶å™¨
extension UIView {
    func findViewController() -> UIViewController? {
        if let nextResponder = self.next as? UIViewController {
            return nextResponder
        } else if let nextResponder = self.next as? UIView {
            return nextResponder.findViewController()
        } else {
            return nil
        }
    }
}```

<Check>
è¿™ç§è®¾è®¡æä¾›äº†ä¸°å¯Œçš„è§†è§‰åé¦ˆï¼ŒåŒ…æ‹¬è¿›åº¦æ¡ã€é˜¶æ®µæ€§æ¶ˆæ¯ã€è€—æ—¶æ˜¾ç¤ºå’ŒåŠ¨ç”»æ•ˆæœï¼Œå¤§å¤§æå‡äº†ç”¨æˆ·ä½“éªŒã€‚
</Check>

### ç½‘ç»œçŠ¶æ€ç›‘å¬

<Warning>
ç½‘ç»œçŠ¶æ€çš„å˜åŒ–ä¼šç›´æ¥å½±å“æ•°å­—äººæ¨¡å‹çš„åŠ è½½å’Œæ¸²æŸ“è´¨é‡ï¼Œéœ€è¦å®æ—¶ç›‘æ§å¹¶åšå‡ºç›¸åº”è°ƒæ•´ã€‚
</Warning>

#### æ™ºèƒ½ç½‘ç»œé€‚é…

```swift title="ç½‘ç»œæ„ŸçŸ¥çš„æ¸²æŸ“å™¨"
import Network

class NetworkAwareAvatarRenderer {
    private let networkMonitor = NWPathMonitor()
    private var renderer: AvatarRenderer?
    private var networkStatus: NetworkStatus = .unknown
    private let networkQueue = DispatchQueue(label: "network.monitor")
    
    enum NetworkStatus {
        case unknown
        case unavailable
        case wifi
        case cellular
        case ethernet
        
        var description: String {
            switch self {
            case .unknown: return "æœªçŸ¥"
            case .unavailable: return "æ— ç½‘ç»œ"
            case .wifi: return "WiFi"
            case .cellular: return "èœ‚çªç½‘ç»œ"
            case .ethernet: return "ä»¥å¤ªç½‘"
            }
        }
        
        var recommendedQuality: RenderQuality {
            switch self {
            case .wifi, .ethernet:
                return .high
            case .cellular:
                return .medium
            case .unavailable, .unknown:
                return .low
            }
        }
    }
    
    func setupNetworkMonitoring() {
        networkMonitor.pathUpdateHandler = { [weak self] path in
            let newStatus = self?.determineNetworkStatus(from: path) ?? .unknown
            
            DispatchQueue.main.async {
                self?.handleNetworkStatusChange(from: self?.networkStatus ?? .unknown, to: newStatus)
                self?.networkStatus = newStatus
            }
        }
        
        networkMonitor.start(queue: networkQueue)
    }
    
    private func determineNetworkStatus(from path: NWPath) -> NetworkStatus {
        guard path.status == .satisfied else {
            return .unavailable
        }
        
        if path.usesInterfaceType(.wifi) {
            return .wifi
        } else if path.usesInterfaceType(.cellular) {
            return .cellular
        } else if path.usesInterfaceType(.wiredEthernet) {
            return .ethernet
        } else {
            return .unknown
        }
    }
    
    private func handleNetworkStatusChange(from oldStatus: NetworkStatus, to newStatus: NetworkStatus) {
        print("ç½‘ç»œçŠ¶æ€å˜åŒ–: \(oldStatus.description) -> \(newStatus.description)")
        
        switch (oldStatus, newStatus) {
        case (_, .unavailable):
            onNetworkUnavailable()
        case (.unavailable, _):
            onNetworkAvailable(newStatus)
        case (.cellular, .wifi), (.wifi, .cellular):
            onNetworkTypeChanged(newStatus)
        default:
            break
        }
    }
    
    private func onNetworkAvailable(_ status: NetworkStatus) {
        print("ç½‘ç»œæ¢å¤: \(status.description)")
        
        // æ ¹æ®ç½‘ç»œç±»å‹è°ƒæ•´æ¸²æŸ“è´¨é‡
        renderer?.quality = status.recommendedQuality
        
        // é‡æ–°åŠ è½½å¤±è´¥çš„æ¨¡å‹
        retryFailedOperations()
        
        // æ˜¾ç¤ºç½‘ç»œæ¢å¤æç¤º
        showNetworkStatusAlert("ç½‘ç»œå·²æ¢å¤", message: "å½“å‰ç½‘ç»œ: \(status.description)")
    }
    
    private func onNetworkUnavailable() {
        print("ç½‘ç»œæ–­å¼€ï¼Œåˆ‡æ¢åˆ°ç¦»çº¿æ¨¡å¼")
        
        // é™ä½æ¸²æŸ“è´¨é‡ä»¥èŠ‚çœèµ„æº
        renderer?.quality = .low
        
        // æš‚åœéå¿…è¦çš„ç½‘ç»œæ“ä½œ
        pauseNetworkOperations()
        
        // æ˜¾ç¤ºç¦»çº¿æ¨¡å¼æç¤º
        showNetworkStatusAlert("ç½‘ç»œè¿æ¥ä¸­æ–­", message: "å·²åˆ‡æ¢åˆ°ç¦»çº¿æ¨¡å¼")
    }
    
    private func onNetworkTypeChanged(_ newStatus: NetworkStatus) {
        print("ç½‘ç»œç±»å‹å˜åŒ–: \(newStatus.description)")
        
        // æ ¹æ®æ–°çš„ç½‘ç»œç±»å‹è°ƒæ•´ç­–ç•¥
        renderer?.quality = newStatus.recommendedQuality
        
        // å¦‚æœä»WiFiåˆ‡æ¢åˆ°èœ‚çªç½‘ç»œï¼Œå¯èƒ½éœ€è¦æš‚åœå¤§æ–‡ä»¶ä¸‹è½½
        if newStatus == .cellular {
            pauseLargeDownloads()
        }
    }
    
    private func retryFailedOperations() {
        // é‡è¯•ä¹‹å‰å› ç½‘ç»œé—®é¢˜å¤±è´¥çš„æ“ä½œ
        // è¿™é‡Œå¯ä»¥å®ç°é‡è¯•é˜Ÿåˆ—é€»è¾‘
    }
    
    private func pauseNetworkOperations() {
        // æš‚åœéå¿…è¦çš„ç½‘ç»œæ“ä½œ
        // ä¾‹å¦‚ï¼šæ¨¡å‹é¢„åŠ è½½ã€åˆ†ææ•°æ®ä¸Šä¼ ç­‰
    }
    
    private func pauseLargeDownloads() {
        // åœ¨èœ‚çªç½‘ç»œä¸‹æš‚åœå¤§æ–‡ä»¶ä¸‹è½½
        // å¯ä»¥è¯¢é—®ç”¨æˆ·æ˜¯å¦ç»§ç»­
    }
    
    private func showNetworkStatusAlert(_ title: String, message: String) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "ç¡®å®š", style: .default))
        
        // æ˜¾ç¤ºè­¦å‘Šï¼ˆéœ€è¦è·å–å½“å‰è§†å›¾æ§åˆ¶å™¨ï¼‰
        DispatchQueue.main.async {
            if let topViewController = UIApplication.shared.topViewController() {
                topViewController.present(alert, animated: true)
            }
        }
    }
    
    deinit {
        networkMonitor.cancel()
    }
}

// UIApplication æ‰©å±•ï¼Œç”¨äºè·å–é¡¶å±‚è§†å›¾æ§åˆ¶å™¨
extension UIApplication {
    func topViewController() -> UIViewController? {
        guard let windowScene = connectedScenes.first as? UIWindowScene,
              let window = windowScene.windows.first else {
            return nil
        }
        
        var topViewController = window.rootViewController
        
        while let presentedViewController = topViewController?.presentedViewController {
            topViewController = presentedViewController
        }
        
        return topViewController
    }
}```

<Tip>
æ ¹æ®ç½‘ç»œç±»å‹è‡ªåŠ¨è°ƒæ•´æ¸²æŸ“è´¨é‡å’Œä¸‹è½½ç­–ç•¥ï¼Œå¯ä»¥ä¸ºç”¨æˆ·æä¾›æ›´å¥½çš„ä½“éªŒå¹¶èŠ‚çœæµé‡ã€‚
</Tip>

## è°ƒè¯•æŠ€å·§

<Info>
æœ‰æ•ˆçš„è°ƒè¯•ç­–ç•¥å¯ä»¥å¸®åŠ©å¿«é€Ÿå®šä½å’Œè§£å†³é—®é¢˜ï¼Œæé«˜å¼€å‘æ•ˆç‡ã€‚
</Info>

### æ—¥å¿—é…ç½®

<Warning>
åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¯·ç¡®ä¿å…³é—­è°ƒè¯•æ—¥å¿—ä»¥é¿å…æ€§èƒ½å½±å“å’Œæ•æ„Ÿä¿¡æ¯æ³„éœ²ã€‚
</Warning>

#### æ™ºèƒ½æ—¥å¿—ç®¡ç†

```swift title="ç¯å¢ƒæ„ŸçŸ¥çš„æ—¥å¿—é…ç½®"
import os.log

class AvatarLogManager {
    enum LogLevel: Int, CaseIterable {
        case verbose = 0
        case debug = 1
        case info = 2
        case warning = 3
        case error = 4
        case critical = 5
        
        var emoji: String {
            switch self {
            case .verbose: return "ğŸ’¬"
            case .debug: return "ğŸ”"
            case .info: return "â„¹ï¸"
            case .warning: return "âš ï¸"
            case .error: return "âŒ"
            case .critical: return "ğŸš¨"
            }
        }
        
        var osLogType: OSLogType {
            switch self {
            case .verbose, .debug: return .debug
            case .info: return .info
            case .warning: return .default
            case .error: return .error
            case .critical: return .fault
            }
        }
    }
    
    static let shared = AvatarLogManager()
    private let subsystem = "com.avatarkit.sdk"
    private let logger = OSLog(subsystem: "com.avatarkit.sdk", category: "General")
    
    var currentLevel: LogLevel = {
        #if DEBUG
        return .verbose
        #elseif STAGING
        return .info
        #else
        return .error
        #endif
    }()
    
    var isRemoteLoggingEnabled = false
    private var logBuffer: [LogEntry] = []
    private let maxBufferSize = 1000
    
    struct LogEntry {
        let timestamp: Date
        let level: LogLevel
        let category: String
        let message: String
        let file: String
        let function: String
        let line: Int
    }
    
    func configure() {
        #if DEBUG
        // å¼€å‘ç¯å¢ƒå¯ç”¨è¯¦ç»†æ—¥å¿—
        AvatarSDK.setLogLevel(.verbose)
        print("ğŸ”§ è°ƒè¯•æ¨¡å¼ï¼šå¯ç”¨è¯¦ç»†æ—¥å¿—")
        #elseif STAGING
        // æµ‹è¯•ç¯å¢ƒå¯ç”¨ä¿¡æ¯æ—¥å¿—
        AvatarSDK.setLogLevel(.info)
        isRemoteLoggingEnabled = true
        print("ğŸ§ª æµ‹è¯•æ¨¡å¼ï¼šå¯ç”¨ä¿¡æ¯æ—¥å¿—å’Œè¿œç¨‹ä¸Šä¼ ")
        #else
        // ç”Ÿäº§ç¯å¢ƒåªè®°å½•é”™è¯¯
        AvatarSDK.setLogLevel(.error)
        isRemoteLoggingEnabled = true
        print("ğŸš€ ç”Ÿäº§æ¨¡å¼ï¼šä»…è®°å½•é”™è¯¯æ—¥å¿—")
        #endif
    }
    
    func log(
        _ message: String,
        level: LogLevel = .info,
        category: String = "SDK",
        file: String = #file,
        function: String = #function,
        line: Int = #line
    ) {
        guard level.rawValue >= currentLevel.rawValue else { return }
        
        let fileName = (file as NSString).lastPathComponent
        let timestamp = Date()
        
        // åˆ›å»ºæ—¥å¿—æ¡ç›®
        let entry = LogEntry(
            timestamp: timestamp,
            level: level,
            category: category,
            message: message,
            file: fileName,
            function: function,
            line: line
        )
        
        // æ§åˆ¶å°è¾“å‡º
        let formattedMessage = formatLogMessage(entry)
        print(formattedMessage)
        
        // ç³»ç»Ÿæ—¥å¿—
        os_log("%{public}@", log: logger, type: level.osLogType, message)
        
        // ç¼“å­˜æ—¥å¿—ç”¨äºè¿œç¨‹ä¸Šä¼ 
        if isRemoteLoggingEnabled {
            addToBuffer(entry)
        }
        
        // å…³é”®é”™è¯¯å¤„ç†
        if level == .critical {
            handleCriticalError(entry)
        }
    }
    
    private func formatLogMessage(_ entry: LogEntry) -> String {
        let timestamp = DateFormatter.logFormatter.string(from: entry.timestamp)
        return "\(timestamp) \(entry.level.emoji) [\(entry.category)] [\(entry.file):\(entry.line)] \(entry.function) - \(entry.message)"
    }
    
    private func addToBuffer(_ entry: LogEntry) {
        logBuffer.append(entry)
        
        // ä¿æŒç¼“å†²åŒºå¤§å°
        if logBuffer.count > maxBufferSize {
            logBuffer.removeFirst(logBuffer.count - maxBufferSize)
        }
    }
    
    private func handleCriticalError(_ entry: LogEntry) {
        // ç«‹å³ä¸Šä¼ å…³é”®é”™è¯¯
        uploadCriticalError(entry)
        
        // è®°å½•åˆ°æœ¬åœ°æ–‡ä»¶
        saveCriticalErrorToFile(entry)
    }
    
    private func uploadCriticalError(_ entry: LogEntry) {
        // å®ç°è¿œç¨‹é”™è¯¯ä¸Šä¼ é€»è¾‘
        // å¯ä»¥é›†æˆ Crashlyticsã€Sentry ç­‰æœåŠ¡
    }
    
    private func saveCriticalErrorToFile(_ entry: LogEntry) {
        // ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶ä»¥é˜²ç½‘ç»œé—®é¢˜
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let logFile = documentsPath.appendingPathComponent("critical_errors.log")
        
        let logLine = "\(entry.timestamp): \(entry.message)\n"
        
        if let data = logLine.data(using: .utf8) {
            if FileManager.default.fileExists(atPath: logFile.path) {
                if let fileHandle = try? FileHandle(forWritingTo: logFile) {
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(data)
                    fileHandle.closeFile()
                }
            } else {
                try? data.write(to: logFile)
            }
        }
    }
    
    func uploadBufferedLogs() {
        guard isRemoteLoggingEnabled && !logBuffer.isEmpty else { return }
        
        // å®ç°æ‰¹é‡æ—¥å¿—ä¸Šä¼ 
        let logsToUpload = logBuffer
        logBuffer.removeAll()
        
        // å¼‚æ­¥ä¸Šä¼ 
        DispatchQueue.global(qos: .utility).async {
            // å®ç°ä¸Šä¼ é€»è¾‘
            self.performLogUpload(logsToUpload)
        }
    }
    
    private func performLogUpload(_ logs: [LogEntry]) {
        // å®ç°å®é™…çš„ä¸Šä¼ é€»è¾‘
        // å¯ä»¥ä½¿ç”¨ URLSession æˆ–å…¶ä»–ç½‘ç»œåº“
    }
}

extension DateFormatter {
    static let logFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss.SSS"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        return formatter
    }()
}

// ä¾¿æ·çš„å…¨å±€æ—¥å¿—å‡½æ•°
func AvatarLog(
    _ message: String,
    level: AvatarLogManager.LogLevel = .info,
    category: String = "SDK",
    file: String = #file,
    function: String = #function,
    line: Int = #line
) {
    AvatarLogManager.shared.log(
        message,
        level: level,
        category: category,
        file: file,
        function: function,
        line: line
    )
}```

<Check>
è¿™ä¸ªæ—¥å¿—ç³»ç»Ÿæ”¯æŒç¯å¢ƒæ„ŸçŸ¥é…ç½®ã€è¿œç¨‹ä¸Šä¼ å’Œå…³é”®é”™è¯¯å¤„ç†ï¼Œé€‚åˆç”Ÿäº§ç¯å¢ƒä½¿ç”¨ã€‚
</Check>

### æ€§èƒ½ç›‘æ§

<Tip>
æ€§èƒ½ç›‘æ§å¯ä»¥å¸®åŠ©è¯†åˆ«ç“¶é¢ˆï¼Œä¼˜åŒ–ç”¨æˆ·ä½“éªŒã€‚å»ºè®®ç›‘æ§å…³é”®æ“ä½œçš„è€—æ—¶å’Œèµ„æºä½¿ç”¨æƒ…å†µã€‚
</Tip>

#### ç»¼åˆæ€§èƒ½ç›‘æ§ç³»ç»Ÿ

```swift title="é«˜çº§æ€§èƒ½ç›‘æ§å™¨"
import QuartzCore
import os.signpost

class AvatarPerformanceMonitor {
    static let shared = AvatarPerformanceMonitor()
    
    private let subsystem = "com.avatarkit.performance"
    private let signpostLog: OSLog
    private var activeOperations: [String: (startTime: CFTimeInterval, signpostID: OSSignpostID)] = [:]
    private var metrics: [String: PerformanceMetric] = [:]
    private let metricsQueue = DispatchQueue(label: "performance.metrics", qos: .utility)
    
    struct PerformanceMetric {
        let operationName: String
        var totalTime: TimeInterval = 0
        var executionCount: Int = 0
        var minTime: TimeInterval = .greatestFiniteMagnitude
        var maxTime: TimeInterval = 0
        var lastExecutionTime: Date = Date()
        
        var averageTime: TimeInterval {
            return executionCount > 0 ? totalTime / Double(executionCount) : 0
        }
        
        mutating func addExecution(duration: TimeInterval) {
            totalTime += duration
            executionCount += 1
            minTime = min(minTime, duration)
            maxTime = max(maxTime, duration)
            lastExecutionTime = Date()
        }
    }
    
    private init() {
        signpostLog = OSLog(subsystem: subsystem, category: "Operations")
    }
    
    func startMonitoring(_ operation: String, metadata: [String: Any] = [:]) {
        let startTime = CACurrentMediaTime()
        let signpostID = OSSignpostID(log: signpostLog)
        
        metricsQueue.async {
            self.activeOperations[operation] = (startTime, signpostID)
        }
        
        // ä½¿ç”¨ os_signpost è¿›è¡Œç³»ç»Ÿçº§æ€§èƒ½è¿½è¸ª
        os_signpost(.begin, log: signpostLog, name: "Operation", signpostID: signpostID, 
                   "%{public}@", operation)
        
        AvatarLog("å¼€å§‹ç›‘æ§æ“ä½œ: \(operation)", level: .debug, category: "Performance")
        
        // è®°å½•å…ƒæ•°æ®
        if !metadata.isEmpty {
            let metadataString = metadata.map { "\($0.key): \($0.value)" }.joined(separator: ", ")
            AvatarLog("æ“ä½œå…ƒæ•°æ®: \(metadataString)", level: .verbose, category: "Performance")
        }
    }
    
    func endMonitoring(_ operation: String, success: Bool = true, errorInfo: String? = nil) {
        metricsQueue.async {
            guard let (startTime, signpostID) = self.activeOperations.removeValue(forKey: operation) else {
                AvatarLog("è­¦å‘Š: æœªæ‰¾åˆ°æ“ä½œ \(operation) çš„å¼€å§‹æ—¶é—´", level: .warning, category: "Performance")
                return
            }
            
            let duration = CACurrentMediaTime() - startTime
            
            // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
            if self.metrics[operation] == nil {
                self.metrics[operation] = PerformanceMetric(operationName: operation)
            }
            self.metrics[operation]?.addExecution(duration: duration)
            
            // ç»“æŸ signpost
            os_signpost(.end, log: self.signpostLog, name: "Operation", signpostID: signpostID)
            
            // è®°å½•æ€§èƒ½æ—¥å¿—
            let status = success ? "æˆåŠŸ" : "å¤±è´¥"
            let durationMs = duration * 1000
            var logMessage = "\(operation) \(status) - è€—æ—¶: \(String(format: "%.2f", durationMs))ms"
            
            if let error = errorInfo {
                logMessage += " - é”™è¯¯: \(error)"
            }
            
            let logLevel: AvatarLogManager.LogLevel = {
                if !success { return .error }
                if duration > 1.0 { return .warning }  // è¶…è¿‡1ç§’çš„æ“ä½œ
                return .info
            }()
            
            AvatarLog(logMessage, level: logLevel, category: "Performance")
            
            // æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
            self.checkPerformanceThresholds(operation: operation, duration: duration)
        }
    }
    
    private func checkPerformanceThresholds(operation: String, duration: TimeInterval) {
        let thresholds: [String: TimeInterval] = [
            "æ¨¡å‹åŠ è½½": 3.0,
            "éŸ³é¢‘åº”ç”¨": 0.5,
            "æ¸²æŸ“åˆå§‹åŒ–": 1.0,
            "ç½‘ç»œè¯·æ±‚": 5.0
        ]
        
        if let threshold = thresholds[operation], duration > threshold {
            AvatarLog(
                "æ€§èƒ½è­¦å‘Š: \(operation) è€—æ—¶ \(String(format: "%.2f", duration))s è¶…è¿‡é˜ˆå€¼ \(threshold)s",
                level: .warning,
                category: "Performance"
            )
            
            // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘æ€§èƒ½ä¼˜åŒ–å»ºè®®æˆ–è‡ªåŠ¨è°ƒæ•´
            suggestOptimization(for: operation, duration: duration)
        }
    }
    
    private func suggestOptimization(for operation: String, duration: TimeInterval) {
        let suggestions: [String: String] = [
            "æ¨¡å‹åŠ è½½": "è€ƒè™‘å¯ç”¨æ¨¡å‹é¢„åŠ è½½æˆ–ä½¿ç”¨æ›´å°çš„æ¨¡å‹æ–‡ä»¶",
            "éŸ³é¢‘åº”ç”¨": "æ£€æŸ¥éŸ³é¢‘æ–‡ä»¶å¤§å°å’Œæ ¼å¼ï¼Œè€ƒè™‘ä½¿ç”¨å‹ç¼©æ ¼å¼",
            "æ¸²æŸ“åˆå§‹åŒ–": "æ£€æŸ¥è®¾å¤‡æ€§èƒ½ï¼Œè€ƒè™‘é™ä½æ¸²æŸ“è´¨é‡",
            "ç½‘ç»œè¯·æ±‚": "æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼Œè€ƒè™‘å¯ç”¨è¯·æ±‚ç¼“å­˜"
        ]
        
        if let suggestion = suggestions[operation] {
            AvatarLog(
                "æ€§èƒ½ä¼˜åŒ–å»ºè®®: \(suggestion)",
                level: .info,
                category: "Performance"
            )
        }
    }
    
    func getMetrics() -> [String: PerformanceMetric] {
        return metricsQueue.sync {
            return metrics
        }
    }
    
    func getMetricsSummary() -> String {
        let currentMetrics = getMetrics()
        
        guard !currentMetrics.isEmpty else {
            return "æš‚æ— æ€§èƒ½æ•°æ®"
        }
        
        var summary = "=== æ€§èƒ½ç›‘æ§æŠ¥å‘Š ===\n"
        
        for (operation, metric) in currentMetrics.sorted(by: { $0.key < $1.key }) {
            summary += "\næ“ä½œ: \(operation)\n"
            summary += "  æ‰§è¡Œæ¬¡æ•°: \(metric.executionCount)\n"
            summary += "  å¹³å‡è€—æ—¶: \(String(format: "%.2f", metric.averageTime * 1000))ms\n"
            summary += "  æœ€çŸ­è€—æ—¶: \(String(format: "%.2f", metric.minTime * 1000))ms\n"
            summary += "  æœ€é•¿è€—æ—¶: \(String(format: "%.2f", metric.maxTime * 1000))ms\n"
            summary += "  æœ€åæ‰§è¡Œ: \(DateFormatter.logFormatter.string(from: metric.lastExecutionTime))\n"
        }
        
        return summary
    }
    
    func resetMetrics() {
        metricsQueue.async {
            self.metrics.removeAll()
            AvatarLog("æ€§èƒ½æŒ‡æ ‡å·²é‡ç½®", level: .info, category: "Performance")
        }
    }
    
    // ä¾¿æ·æ–¹æ³•ï¼šç›‘æ§ä»£ç å—æ‰§è¡Œ
    func monitor<T>(
        operation: String,
        metadata: [String: Any] = [:],
        execute: () throws -> T
    ) rethrows -> T {
        startMonitoring(operation, metadata: metadata)
        
        do {
            let result = try execute()
            endMonitoring(operation, success: true)
            return result
        } catch {
            endMonitoring(operation, success: false, errorInfo: error.localizedDescription)
            throw error
        }
    }
    
    // å¼‚æ­¥æ“ä½œç›‘æ§
    func monitorAsync<T>(
        operation: String,
        metadata: [String: Any] = [:],
        execute: @escaping () async throws -> T
    ) async rethrows -> T {
        startMonitoring(operation, metadata: metadata)
        
        do {
            let result = try await execute()
            endMonitoring(operation, success: true)
            return result
        } catch {
            endMonitoring(operation, success: false, errorInfo: error.localizedDescription)
            throw error
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
extension AvatarRenderer {
    func loadModelWithMonitoring(modelId: String) async {
        await AvatarPerformanceMonitor.shared.monitorAsync(
            operation: "æ¨¡å‹åŠ è½½",
            metadata: ["modelId": modelId, "deviceModel": UIDevice.current.model]
        ) {
            // å®é™…çš„æ¨¡å‹åŠ è½½é€»è¾‘
            try await self.loadModel(modelId: modelId)
        }
    }
}```

<Info>
ä½¿ç”¨ os_signpost å¯ä»¥åœ¨ Instruments ä¸­æŸ¥çœ‹è¯¦ç»†çš„æ€§èƒ½åˆ†æï¼Œè¿™å¯¹äºæ·±åº¦æ€§èƒ½ä¼˜åŒ–éå¸¸æœ‰ç”¨ã€‚
</Info>

## å®‰å…¨è€ƒè™‘

<Warning>
å®‰å…¨æ€§æ˜¯ç”Ÿäº§ç¯å¢ƒä¸­çš„å…³é”®è€ƒè™‘å› ç´ ã€‚è¯·ç¡®ä¿éµå¾ªæœ€ä½³å®‰å…¨å®è·µï¼Œä¿æŠ¤ç”¨æˆ·æ•°æ®å’Œåº”ç”¨ç¨‹åºã€‚
</Warning>

### é…ç½®å®‰å…¨

<Info>
æ•æ„Ÿé…ç½®ä¿¡æ¯åº”è¯¥é€šè¿‡å®‰å…¨çš„æ–¹å¼ç®¡ç†ï¼Œé¿å…ç¡¬ç¼–ç åœ¨æºä»£ç ä¸­ã€‚
</Info>

#### å®‰å…¨é…ç½®ç®¡ç†

```swift title="å®‰å…¨çš„é…ç½®ç®¡ç†ç³»ç»Ÿ"
import Security
import CryptoKit

class SecureConfigManager {
    static let shared = SecureConfigManager()
    
    private let keychainService = "com.avatarkit.config"
    private let configQueue = DispatchQueue(label: "config.secure", qos: .userInitiated)
    
    enum ConfigKey: String, CaseIterable {
        case appId = "AVATAR_APP_ID"
        case appSecret = "AVATAR_APP_SECRET"
        case apiEndpoint = "AVATAR_API_ENDPOINT"
        case encryptionKey = "AVATAR_ENCRYPTION_KEY"
        
        var isRequired: Bool {
            switch self {
            case .appId, .appSecret:
                return true
            case .apiEndpoint, .encryptionKey:
                return false
            }
        }
    }
    
    private init() {
        validateConfiguration()
    }
    
    // ä»å¤šä¸ªæ¥æºè·å–é…ç½®
    func getConfig(for key: ConfigKey) -> String? {
        // 1. é¦–å…ˆå°è¯•ä» Keychain è·å–
        if let keychainValue = getFromKeychain(key: key.rawValue) {
            return keychainValue
        }
        
        // 2. ç„¶åå°è¯•ä»ç¯å¢ƒå˜é‡è·å–
        if let envValue = ProcessInfo.processInfo.environment[key.rawValue] {
            // å°†ç¯å¢ƒå˜é‡å€¼å­˜å‚¨åˆ° Keychain ä»¥ä¾›åç»­ä½¿ç”¨
            saveToKeychain(key: key.rawValue, value: envValue)
            return envValue
        }
        
        // 3. æœ€åå°è¯•ä»é…ç½®æ–‡ä»¶è·å–
        if let fileValue = getFromConfigFile(key: key.rawValue) {
            return fileValue
        }
        
        // 4. å¦‚æœæ˜¯å¿…éœ€çš„é…ç½®ä½†æœªæ‰¾åˆ°ï¼Œè®°å½•é”™è¯¯
        if key.isRequired {
            AvatarLog("å…³é”®é…ç½®ç¼ºå¤±: \(key.rawValue)", level: .critical, category: "Security")
        }
        
        return nil
    }
    
    private func getFromKeychain(key: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess,
              let data = result as? Data,
              let value = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        return value
    }
    
    private func saveToKeychain(key: String, value: String) {
        guard let data = value.data(using: .utf8) else { return }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: key,
            kSecValueData as String: data
        ]
        
        // å…ˆåˆ é™¤ç°æœ‰é¡¹ç›®
        SecItemDelete(query as CFDictionary)
        
        // æ·»åŠ æ–°é¡¹ç›®
        let status = SecItemAdd(query as CFDictionary, nil)
        
        if status != errSecSuccess {
            AvatarLog("Keychain å­˜å‚¨å¤±è´¥: \(key)", level: .error, category: "Security")
        }
    }
    
    private func getFromConfigFile(key: String) -> String? {
        guard let path = Bundle.main.path(forResource: "AvatarConfig", ofType: "plist"),
              let plist = NSDictionary(contentsOfFile: path) else {
            return nil
        }
        
        return plist[key] as? String
    }
    
    private func validateConfiguration() {
        configQueue.async {
            var missingConfigs: [ConfigKey] = []
            
            for configKey in ConfigKey.allCases {
                if configKey.isRequired && self.getConfig(for: configKey) == nil {
                    missingConfigs.append(configKey)
                }
            }
            
            if !missingConfigs.isEmpty {
                let missingKeys = missingConfigs.map { $0.rawValue }.joined(separator: ", ")
                AvatarLog(
                    "é…ç½®éªŒè¯å¤±è´¥ï¼Œç¼ºå°‘å¿…éœ€é…ç½®: \(missingKeys)",
                    level: .critical,
                    category: "Security"
                )
                
                #if DEBUG
                fatalError("å…³é”®é…ç½®ç¼ºå¤±: \(missingKeys)")
                #endif
            } else {
                AvatarLog("é…ç½®éªŒè¯é€šè¿‡", level: .info, category: "Security")
            }
        }
    }
    
    // å®‰å…¨åœ°æ¸…é™¤æ•æ„Ÿé…ç½®
    func clearSensitiveData() {
        for configKey in ConfigKey.allCases {
            let query: [String: Any] = [
                kSecClass as String: kSecClassGenericPassword,
                kSecAttrService as String: keychainService,
                kSecAttrAccount as String: configKey.rawValue
            ]
            
            SecItemDelete(query as CFDictionary)
        }
        
        AvatarLog("æ•æ„Ÿé…ç½®å·²æ¸…é™¤", level: .info, category: "Security")
    }
}

// ä¾¿æ·çš„é…ç½®è®¿é—®
struct AvatarConfig {
    static var appId: String {
        guard let appId = SecureConfigManager.shared.getConfig(for: .appId) else {
            fatalError("AVATAR_APP_ID é…ç½®æœªè®¾ç½®")
        }
        return appId
    }
    
    static var appSecret: String {
        guard let appSecret = SecureConfigManager.shared.getConfig(for: .appSecret) else {
            fatalError("AVATAR_APP_SECRET é…ç½®æœªè®¾ç½®")
        }
        return appSecret
    }
    
    static var apiEndpoint: String {
        return SecureConfigManager.shared.getConfig(for: .apiEndpoint) ?? "https://api.avatarkit.com"
    }
}```

<Check>
è¿™ä¸ªé…ç½®ç®¡ç†ç³»ç»Ÿæ”¯æŒå¤šç§é…ç½®æ¥æºï¼Œå¹¶ä½¿ç”¨ Keychain å®‰å…¨å­˜å‚¨æ•æ„Ÿä¿¡æ¯ã€‚
</Check>

### è¾“å…¥éªŒè¯

<Warning>
æ‰€æœ‰å¤–éƒ¨è¾“å…¥éƒ½åº”è¯¥ç»è¿‡ä¸¥æ ¼éªŒè¯ï¼Œä»¥é˜²æ­¢å®‰å…¨æ¼æ´å’Œæ¶æ„æ”»å‡»ã€‚
</Warning>

#### ç»¼åˆè¾“å…¥éªŒè¯ç³»ç»Ÿ

```swift title="å®‰å…¨çš„è¾“å…¥éªŒè¯å™¨"
import Foundation
import Network

class InputValidator {
    static let shared = InputValidator()
    
    // URL éªŒè¯é…ç½®
    struct URLValidationConfig {
        let allowedSchemes: Set<String>
        let allowedDomains: Set<String>
        let maxPathLength: Int
        let allowedFileExtensions: Set<String>
        
        static let `default` = URLValidationConfig(
            allowedSchemes: ["https"],
            allowedDomains: ["cdn.avatarkit.com", "assets.avatarkit.com", "api.avatarkit.com"],
            maxPathLength: 500,
            allowedFileExtensions: ["avatar", "json", "wav", "mp3", "m4a"]
        )
    }
    
    // æ–‡æœ¬éªŒè¯é…ç½®
    struct TextValidationConfig {
        let maxLength: Int
        let allowedCharacters: CharacterSet
        let forbiddenPatterns: [String]
        
        static let modelId = TextValidationConfig(
            maxLength: 100,
            allowedCharacters: CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "-_")),
            forbiddenPatterns: ["<script", "javascript:", "data:"]
        )
        
        static let audioText = TextValidationConfig(
            maxLength: 1000,
            allowedCharacters: CharacterSet.alphanumerics.union(CharacterSet.punctuationCharacters).union(CharacterSet.whitespaces),
            forbiddenPatterns: ["<script", "javascript:", "data:", "<?php"]
        )
    }
    
    enum ValidationError: LocalizedError {
        case invalidScheme(String)
        case unauthorizedDomain(String)
        case pathTooLong(Int)
        case invalidFileExtension(String)
        case textTooLong(Int)
        case invalidCharacters(String)
        case forbiddenPattern(String)
        case malformedURL
        case networkValidationFailed
        
        var errorDescription: String? {
            switch self {
            case .invalidScheme(let scheme):
                return "ä¸æ”¯æŒçš„åè®®: \(scheme)"
            case .unauthorizedDomain(let domain):
                return "æœªæˆæƒçš„åŸŸå: \(domain)"
            case .pathTooLong(let length):
                return "è·¯å¾„è¿‡é•¿: \(length) å­—ç¬¦"
            case .invalidFileExtension(let ext):
                return "ä¸æ”¯æŒçš„æ–‡ä»¶æ‰©å±•å: \(ext)"
            case .textTooLong(let length):
                return "æ–‡æœ¬è¿‡é•¿: \(length) å­—ç¬¦"
            case .invalidCharacters(let text):
                return "åŒ…å«éæ³•å­—ç¬¦: \(text)"
            case .forbiddenPattern(let pattern):
                return "åŒ…å«ç¦æ­¢çš„æ¨¡å¼: \(pattern)"
            case .malformedURL:
                return "URL æ ¼å¼é”™è¯¯"
            case .networkValidationFailed:
                return "ç½‘ç»œéªŒè¯å¤±è´¥"
            }
        }
    }
    
    private init() {}
    
    // URL éªŒè¯
    func validateURL(_ url: URL, config: URLValidationConfig = .default) throws {
        // 1. æ£€æŸ¥åè®®
        guard let scheme = url.scheme?.lowercased(),
              config.allowedSchemes.contains(scheme) else {
            throw ValidationError.invalidScheme(url.scheme ?? "unknown")
        }
        
        // 2. æ£€æŸ¥åŸŸå
        guard let host = url.host?.lowercased(),
              config.allowedDomains.contains(host) else {
            throw ValidationError.unauthorizedDomain(url.host ?? "unknown")
        }
        
        // 3. æ£€æŸ¥è·¯å¾„é•¿åº¦
        let pathLength = url.path.count
        guard pathLength <= config.maxPathLength else {
            throw ValidationError.pathTooLong(pathLength)
        }
        
        // 4. æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
        let fileExtension = url.pathExtension.lowercased()
        if !fileExtension.isEmpty && !config.allowedFileExtensions.contains(fileExtension) {
            throw ValidationError.invalidFileExtension(fileExtension)
        }
        
        // 5. é¢å¤–çš„å®‰å…¨æ£€æŸ¥
        try performAdditionalURLChecks(url)
        
        AvatarLog("URL éªŒè¯é€šè¿‡: \(url.absoluteString)", level: .debug, category: "Security")
    }
    
    private func performAdditionalURLChecks(_ url: URL) throws {
        let urlString = url.absoluteString
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«å¯ç–‘çš„ç¼–ç å­—ç¬¦
        let suspiciousPatterns = [
            "%3Cscript",  // <script
            "%3C%2Fscript", // </script
            "javascript%3A", // javascript:
            "data%3A", // data:
            "%00", // null byte
            "../", // path traversal
            "..%2F" // encoded path traversal
        ]
        
        for pattern in suspiciousPatterns {
            if urlString.lowercased().contains(pattern.lowercased()) {
                throw ValidationError.forbiddenPattern(pattern)
            }
        }
    }
    
    // æ–‡æœ¬éªŒè¯
    func validateText(_ text: String, config: TextValidationConfig) throws {
        // 1. æ£€æŸ¥é•¿åº¦
        guard text.count <= config.maxLength else {
            throw ValidationError.textTooLong(text.count)
        }
        
        // 2. æ£€æŸ¥å­—ç¬¦é›†
        let textCharacterSet = CharacterSet(charactersIn: text)
        guard config.allowedCharacters.isSuperset(of: textCharacterSet) else {
            throw ValidationError.invalidCharacters(text)
        }
        
        // 3. æ£€æŸ¥ç¦æ­¢çš„æ¨¡å¼
        let lowercaseText = text.lowercased()
        for pattern in config.forbiddenPatterns {
            if lowercaseText.contains(pattern.lowercased()) {
                throw ValidationError.forbiddenPattern(pattern)
            }
        }
        
        AvatarLog("æ–‡æœ¬éªŒè¯é€šè¿‡: \(text.prefix(50))...", level: .debug, category: "Security")
    }
    
    // æ¨¡å‹ ID éªŒè¯
    func validateModelId(_ modelId: String) throws {
        try validateText(modelId, config: .modelId)
        
        // é¢å¤–çš„æ¨¡å‹ ID ç‰¹å®šæ£€æŸ¥
        guard !modelId.isEmpty else {
            throw ValidationError.invalidCharacters("æ¨¡å‹ ID ä¸èƒ½ä¸ºç©º")
        }
        
        guard modelId.first?.isLetter == true else {
            throw ValidationError.invalidCharacters("æ¨¡å‹ ID å¿…é¡»ä»¥å­—æ¯å¼€å¤´")
        }
    }
    
    // éŸ³é¢‘æ–‡æœ¬éªŒè¯
    func validateAudioText(_ text: String) throws {
        try validateText(text, config: .audioText)
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«è¿‡å¤šçš„é‡å¤å­—ç¬¦ï¼ˆå¯èƒ½çš„ DoS æ”»å‡»ï¼‰
        if hasExcessiveRepetition(text) {
            throw ValidationError.forbiddenPattern("è¿‡å¤šé‡å¤å­—ç¬¦")
        }
    }
    
    private func hasExcessiveRepetition(_ text: String) -> Bool {
        let maxRepetition = 10
        var currentChar: Character?
        var repetitionCount = 0
        
        for char in text {
            if char == currentChar {
                repetitionCount += 1
                if repetitionCount > maxRepetition {
                    return true
                }
            } else {
                currentChar = char
                repetitionCount = 1
            }
        }
        
        return false
    }
    
    // ç½‘ç»œè¿æ¥éªŒè¯ï¼ˆå¼‚æ­¥ï¼‰
    func validateNetworkConnection(to url: URL) async throws {
        let monitor = NWPathMonitor()
        let queue = DispatchQueue(label: "network.validation")
        
        return try await withCheckedThrowingContinuation { continuation in
            monitor.pathUpdateHandler = { path in
                monitor.cancel()
                
                if path.status == .satisfied {
                    continuation.resume()
                } else {
                    continuation.resume(throwing: ValidationError.networkValidationFailed)
                }
            }
            
            monitor.start(queue: queue)
            
            // è®¾ç½®è¶…æ—¶
            DispatchQueue.global().asyncAfter(deadline: .now() + 5.0) {
                monitor.cancel()
                continuation.resume(throwing: ValidationError.networkValidationFailed)
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
extension AvatarRenderer {
    func loadModelSafely(from url: URL, modelId: String) async throws {
        // éªŒè¯è¾“å…¥
        try InputValidator.shared.validateURL(url)
        try InputValidator.shared.validateModelId(modelId)
        
        // éªŒè¯ç½‘ç»œè¿æ¥
        try await InputValidator.shared.validateNetworkConnection(to: url)
        
        AvatarLog("è¾“å…¥éªŒè¯é€šè¿‡ï¼Œå¼€å§‹åŠ è½½æ¨¡å‹", level: .info, category: "Security")
        
        // æ‰§è¡Œå®é™…çš„æ¨¡å‹åŠ è½½
        try await loadModel(from: url, modelId: modelId)
    }
    
    func applyAudioSafely(text: String) throws {
        // éªŒè¯éŸ³é¢‘æ–‡æœ¬
        try InputValidator.shared.validateAudioText(text)
        
        AvatarLog("éŸ³é¢‘æ–‡æœ¬éªŒè¯é€šè¿‡", level: .info, category: "Security")
        
        // æ‰§è¡Œå®é™…çš„éŸ³é¢‘åº”ç”¨
        try applyAudio(text: text)
    }
}```

<Tip>
å®šæœŸæ›´æ–°éªŒè¯è§„åˆ™å’Œå®‰å…¨ç­–ç•¥ï¼Œä»¥åº”å¯¹æ–°çš„å®‰å…¨å¨èƒå’Œæ”»å‡»æ–¹å¼ã€‚
</Tip>
    
    // æ£€æŸ¥åŸŸåç™½åå•
    let allowedDomains = ["cdn.example.com", "assets.example.com"]
    guard let host = url.host, allowedDomains.contains(host) else {
        print("ä¸æ”¯æŒçš„åŸŸå: \(url.host ?? "unknown")")
        return false
    }
    
    return true
}
```

## æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

<Warning>
å•å…ƒæµ‹è¯•åº”è¯¥è¦†ç›–æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µï¼Œç¡®ä¿ä»£ç è´¨é‡å’Œç¨³å®šæ€§ã€‚
</Warning>

#### å…¨é¢çš„å•å…ƒæµ‹è¯•å¥—ä»¶

```swift title="æ ¸å¿ƒåŠŸèƒ½å•å…ƒæµ‹è¯•"
import XCTest
import Combine
@testable import AvatarKit

class AvatarRendererTests: XCTestCase {
    var renderer: AvatarRenderer!
    var mockDelegate: MockAvatarRendererDelegate!
    var cancellables: Set<AnyCancellable>!
    
    override func setUp() {
        super.setUp()
        renderer = AvatarRenderer(frame: .zero)
        mockDelegate = MockAvatarRendererDelegate()
        renderer.delegate = mockDelegate
        cancellables = Set<AnyCancellable>()
    }
    
    override func tearDown() {
        cancellables.removeAll()
        renderer = nil
        mockDelegate = nil
        super.tearDown()
    }
    
    // MARK: - åˆå§‹åŒ–æµ‹è¯•
    
    func testInitialization() {
        XCTAssertNotNil(renderer)
        XCTAssertEqual(renderer.state, .idle)
        XCTAssertNil(renderer.currentModel)
        XCTAssertFalse(renderer.isLoading)
    }
    
    func testInitializationWithConfig() {
        let config = AvatarConfig(
            renderQuality: .high,
            enableAudio: true,
            maxCacheSize: 100 * 1024 * 1024
        )
        
        let configuredRenderer = AvatarRenderer(frame: .zero, config: config)
        XCTAssertEqual(configuredRenderer.config.renderQuality, .high)
        XCTAssertTrue(configuredRenderer.config.enableAudio)
    }
    
    // MARK: - æ¨¡å‹åŠ è½½æµ‹è¯•
    
    func testModelLoadingSuccess() async throws {
        let expectation = expectation(description: "Model loading success")
        let testURL = URL(string: "https://cdn.avatarkit.com/test-model.avatar")!
        
        mockDelegate.onDidLoadModel = {
            expectation.fulfill()
        }
        
        try await renderer.loadModel(from: testURL)
        
        await fulfillment(of: [expectation], timeout: 10.0)
        
        XCTAssertEqual(renderer.state, .ready)
        XCTAssertNotNil(renderer.currentModel)
        XCTAssertTrue(mockDelegate.didLoadModelCalled)
    }
    
    func testModelLoadingFailure() async {
        let expectation = expectation(description: "Model loading failure")
        let invalidURL = URL(string: "https://invalid-domain.com/model.avatar")!
        
        mockDelegate.onDidFailWithError = { error in
            XCTAssertTrue(error is AvatarError)
            expectation.fulfill()
        }
        
        do {
            try await renderer.loadModel(from: invalidURL)
            XCTFail("Expected model loading to fail")
        } catch {
            // é¢„æœŸçš„é”™è¯¯
        }
        
        await fulfillment(of: [expectation], timeout: 5.0)
        
        XCTAssertEqual(renderer.state, .error)
        XCTAssertTrue(mockDelegate.didFailWithErrorCalled)
    }
    
    func testModelLoadingCancellation() async throws {
        let testURL = URL(string: "https://cdn.avatarkit.com/large-model.avatar")!
        
        // å¼€å§‹åŠ è½½
        let loadingTask = Task {
            try await renderer.loadModel(from: testURL)
        }
        
        // ç«‹å³å–æ¶ˆ
        loadingTask.cancel()
        
        do {
            try await loadingTask.value
            XCTFail("Expected task to be cancelled")
        } catch {
            XCTAssertTrue(error is CancellationError)
        }
        
        XCTAssertEqual(renderer.state, .idle)
    }
    
    // MARK: - éŸ³é¢‘åº”ç”¨æµ‹è¯•
    
    func testAudioApplicationSuccess() async throws {
        // é¦–å…ˆåŠ è½½æ¨¡å‹
        let testURL = URL(string: "https://cdn.avatarkit.com/test-model.avatar")!
        try await renderer.loadModel(from: testURL)
        
        let expectation = expectation(description: "Audio application success")
        let testText = "Hello, this is a test message."
        
        mockDelegate.onDidApplyAudio = {
            expectation.fulfill()
        }
        
        try await renderer.applyAudio(text: testText)
        
        await fulfillment(of: [expectation], timeout: 10.0)
        
        XCTAssertTrue(mockDelegate.didApplyAudioCalled)
    }
    
    func testAudioApplicationWithoutModel() async {
        let testText = "Hello, world!"
        
        do {
            try await renderer.applyAudio(text: testText)
            XCTFail("Expected audio application to fail without model")
        } catch let error as AvatarError {
            XCTAssertEqual(error, .modelNotLoaded)
        } catch {
            XCTFail("Unexpected error type: \(error)")
        }
    }
    
    func testAudioApplicationWithEmptyText() async throws {
        // é¦–å…ˆåŠ è½½æ¨¡å‹
        let testURL = URL(string: "https://cdn.avatarkit.com/test-model.avatar")!
        try await renderer.loadModel(from: testURL)
        
        do {
            try await renderer.applyAudio(text: "")
            XCTFail("Expected audio application to fail with empty text")
        } catch let error as AvatarError {
            XCTAssertEqual(error, .invalidInput)
        } catch {
            XCTFail("Unexpected error type: \(error)")
        }
    }
    
    // MARK: - çŠ¶æ€ç®¡ç†æµ‹è¯•
    
    func testStateTransitions() async throws {
        var stateChanges: [AvatarRenderer.State] = []
        
        renderer.statePublisher
            .sink { state in
                stateChanges.append(state)
            }
            .store(in: &cancellables)
        
        let testURL = URL(string: "https://cdn.avatarkit.com/test-model.avatar")!
        
        // åŠ è½½æ¨¡å‹
        try await renderer.loadModel(from: testURL)
        
        // åº”ç”¨éŸ³é¢‘
        try await renderer.applyAudio(text: "Test message")
        
        // éªŒè¯çŠ¶æ€è½¬æ¢åºåˆ—
        let expectedStates: [AvatarRenderer.State] = [.idle, .loading, .ready, .processing, .ready]
        XCTAssertEqual(stateChanges, expectedStates)
    }
    
    // MARK: - å†…å­˜ç®¡ç†æµ‹è¯•
    
    func testMemoryManagement() {
        weak var weakRenderer: AvatarRenderer?
        
        autoreleasepool {
            let tempRenderer = AvatarRenderer(frame: .zero)
            weakRenderer = tempRenderer
            // tempRenderer åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸ
        }
        
        XCTAssertNil(weakRenderer, "AvatarRenderer should be deallocated")
    }
    
    func testDelegateWeakReference() {
        weak var weakDelegate: MockAvatarRendererDelegate?
        
        autoreleasepool {
            let tempDelegate = MockAvatarRendererDelegate()
            weakDelegate = tempDelegate
            renderer.delegate = tempDelegate
            // tempDelegate åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸ
        }
        
        XCTAssertNil(weakDelegate, "Delegate should be deallocated")
        XCTAssertNil(renderer.delegate, "Renderer should not retain delegate")
    }
}

// MARK: - Mock Delegate

class MockAvatarRendererDelegate: AvatarRendererDelegate {
    var didStartCalled = false
    var didStopCalled = false
    var didLoadModelCalled = false
    var didApplyAudioCalled = false
    var didFailWithErrorCalled = false
    var didUpdateProgressCalled = false
    
    var onDidStart: (() -> Void)?
    var onDidStop: (() -> Void)?
    var onDidLoadModel: (() -> Void)?
    var onDidApplyAudio: (() -> Void)?
    var onDidFailWithError: ((Error) -> Void)?
    var onDidUpdateProgress: ((Float, String?) -> Void)?
    
    func avatarRendererDidStart(_ renderer: AvatarRenderer) {
        didStartCalled = true
        onDidStart?()
    }
    
    func avatarRendererDidStop(_ renderer: AvatarRenderer) {
        didStopCalled = true
        onDidStop?()
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didLoadModel model: AvatarModel) {
        didLoadModelCalled = true
        onDidLoadModel?()
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didApplyAudio audioData: Data) {
        didApplyAudioCalled = true
        onDidApplyAudio?()
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didFailWithError error: Error) {
        didFailWithErrorCalled = true
        onDidFailWithError?(error)
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didUpdateProgress progress: Float, message: String?) {
        didUpdateProgressCalled = true
        onDidUpdateProgress?(progress, message)
    }
}```

<Check>
è¿™ä¸ªæµ‹è¯•å¥—ä»¶è¦†ç›–äº†åˆå§‹åŒ–ã€æ¨¡å‹åŠ è½½ã€éŸ³é¢‘åº”ç”¨ã€çŠ¶æ€ç®¡ç†å’Œå†…å­˜ç®¡ç†ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚
</Check>

### é›†æˆæµ‹è¯•

<Info>
é›†æˆæµ‹è¯•éªŒè¯ä¸åŒç»„ä»¶ä¹‹é—´çš„åä½œï¼Œç¡®ä¿æ•´ä¸ªç³»ç»Ÿçš„æ­£å¸¸è¿è¡Œã€‚
</Info>

#### ç«¯åˆ°ç«¯é›†æˆæµ‹è¯•

```swift title="å®Œæ•´å·¥ä½œæµç¨‹é›†æˆæµ‹è¯•"
class AvatarIntegrationTests: XCTestCase {
    var renderer: AvatarRenderer!
    var testModelURL: URL!
    var performanceMonitor: AvatarPerformanceMonitor!
    
    override func setUp() {
        super.setUp()
        
        let config = AvatarConfig(
            renderQuality: .medium,
            enableAudio: true,
            maxCacheSize: 50 * 1024 * 1024
        )
        
        renderer = AvatarRenderer(frame: CGRect(x: 0, y: 0, width: 300, height: 400), config: config)
        testModelURL = URL(string: "https://cdn.avatarkit.com/integration-test-model.avatar")!
        performanceMonitor = AvatarPerformanceMonitor.shared
    }
    
    override func tearDown() {
        renderer = nil
        performanceMonitor = nil
        super.tearDown()
    }
    
    // MARK: - å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•
    
    func testCompleteWorkflow() async throws {
        let expectation = expectation(description: "Complete workflow")
        var workflowSteps: [String] = []
        
        let delegate = WorkflowTrackingDelegate { step in
            workflowSteps.append(step)
            if step == "audio_applied" {
                expectation.fulfill()
            }
        }
        
        renderer.delegate = delegate
        
        // 1. åŠ è½½æ¨¡å‹
        try await renderer.loadModel(from: testModelURL)
        
        // 2. åº”ç”¨éŸ³é¢‘
        try await renderer.applyAudio(text: "This is an integration test message.")
        
        await fulfillment(of: [expectation], timeout: 30.0)
        
        let expectedSteps = ["model_loaded", "audio_applied"]
        XCTAssertEqual(workflowSteps, expectedSteps)
    }
    
    func testMultipleAudioApplications() async throws {
        // åŠ è½½æ¨¡å‹
        try await renderer.loadModel(from: testModelURL)
        
        let audioTexts = [
            "First message",
            "Second message",
            "Third message"
        ]
        
        for (index, text) in audioTexts.enumerated() {
            let expectation = expectation(description: "Audio application \(index + 1)")
            
            let delegate = SimpleCompletionDelegate {
                expectation.fulfill()
            }
            
            renderer.delegate = delegate
            
            try await renderer.applyAudio(text: text)
            
            await fulfillment(of: [expectation], timeout: 15.0)
        }
    }
    
    func testConcurrentOperations() async throws {
        // æµ‹è¯•å¹¶å‘æ“ä½œçš„å¤„ç†
        try await renderer.loadModel(from: testModelURL)
        
        let concurrentTasks = (1...5).map { index in
            Task {
                try await renderer.applyAudio(text: "Concurrent message \(index)")
            }
        }
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        for task in concurrentTasks {
            try await task.value
        }
    }
    
    // MARK: - æ€§èƒ½æµ‹è¯•
    
    func testModelLoadingPerformance() async throws {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        try await renderer.loadModel(from: testModelURL)
        
        let loadingTime = CFAbsoluteTimeGetCurrent() - startTime
        
        // æ¨¡å‹åŠ è½½åº”è¯¥åœ¨ 10 ç§’å†…å®Œæˆ
        XCTAssertLessThan(loadingTime, 10.0, "Model loading took too long: \(loadingTime) seconds")
        
        // è®°å½•æ€§èƒ½æŒ‡æ ‡
        performanceMonitor.recordMetric(
            name: "model_loading_time",
            value: loadingTime,
            category: "performance"
        )
    }
    
    func testAudioProcessingPerformance() async throws {
        try await renderer.loadModel(from: testModelURL)
        
        let testText = "This is a performance test message for audio processing."
        let startTime = CFAbsoluteTimeGetCurrent()
        
        try await renderer.applyAudio(text: testText)
        
        let processingTime = CFAbsoluteTimeGetCurrent() - startTime
        
        // éŸ³é¢‘å¤„ç†åº”è¯¥åœ¨ 5 ç§’å†…å®Œæˆ
        XCTAssertLessThan(processingTime, 5.0, "Audio processing took too long: \(processingTime) seconds")
        
        performanceMonitor.recordMetric(
            name: "audio_processing_time",
            value: processingTime,
            category: "performance"
        )
    }
    
    func testMemoryUsage() async throws {
        let initialMemory = getMemoryUsage()
        
        // åŠ è½½æ¨¡å‹
        try await renderer.loadModel(from: testModelURL)
        
        let afterLoadingMemory = getMemoryUsage()
        
        // åº”ç”¨å¤šä¸ªéŸ³é¢‘
        for i in 1...10 {
            try await renderer.applyAudio(text: "Memory test message \(i)")
        }
        
        let finalMemory = getMemoryUsage()
        
        // å†…å­˜å¢é•¿åº”è¯¥åœ¨åˆç†èŒƒå›´å†…ï¼ˆå°äº 100MBï¼‰
        let memoryIncrease = finalMemory - initialMemory
        XCTAssertLessThan(memoryIncrease, 100 * 1024 * 1024, "Memory usage increased too much: \(memoryIncrease) bytes")
        
        performanceMonitor.recordMetric(
            name: "memory_usage_increase",
            value: Double(memoryIncrease),
            category: "memory"
        )
    }
    
    // MARK: - é”™è¯¯æ¢å¤æµ‹è¯•
    
    func testNetworkErrorRecovery() async throws {
        // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯åçš„æ¢å¤
        let invalidURL = URL(string: "https://invalid-domain.com/model.avatar")!
        
        do {
            try await renderer.loadModel(from: invalidURL)
            XCTFail("Expected network error")
        } catch {
            // é¢„æœŸçš„ç½‘ç»œé”™è¯¯
        }
        
        // éªŒè¯å¯ä»¥ä»é”™è¯¯ä¸­æ¢å¤
        try await renderer.loadModel(from: testModelURL)
        XCTAssertEqual(renderer.state, .ready)
    }
    
    func testModelCorruptionHandling() async {
        let corruptModelURL = URL(string: "https://cdn.avatarkit.com/corrupt-model.avatar")!
        
        do {
            try await renderer.loadModel(from: corruptModelURL)
            XCTFail("Expected model corruption error")
        } catch let error as AvatarError {
            XCTAssertEqual(error, .modelCorrupted)
        } catch {
            XCTFail("Unexpected error type: \(error)")
        }
    }
    
    // MARK: - è¾…åŠ©æ–¹æ³•
    
    private func getMemoryUsage() -> Int64 {
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_,
                         task_flavor_t(MACH_TASK_BASIC_INFO),
                         $0,
                         &count)
            }
        }
        
        if kerr == KERN_SUCCESS {
            return Int64(info.resident_size)
        } else {
            return 0
        }
    }
}

// MARK: - æµ‹è¯•è¾…åŠ©ç±»

class WorkflowTrackingDelegate: AvatarRendererDelegate {
    private let onStep: (String) -> Void
    
    init(onStep: @escaping (String) -> Void) {
        self.onStep = onStep
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didLoadModel model: AvatarModel) {
        onStep("model_loaded")
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didApplyAudio audioData: Data) {
        onStep("audio_applied")
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didFailWithError error: Error) {
        onStep("error_occurred")
    }
}

class SimpleCompletionDelegate: AvatarRendererDelegate {
    private let onCompletion: () -> Void
    
    init(onCompletion: @escaping () -> Void) {
        self.onCompletion = onCompletion
    }
    
    func avatarRenderer(_ renderer: AvatarRenderer, didApplyAudio audioData: Data) {
        onCompletion()
    }
}```

<Tip>
å®šæœŸè¿è¡Œé›†æˆæµ‹è¯•å’Œæ€§èƒ½æµ‹è¯•ï¼Œç¡®ä¿ SDK åœ¨ä¸åŒåœºæ™¯ä¸‹çš„ç¨³å®šæ€§å’Œæ€§èƒ½è¡¨ç°ã€‚
</Tip>
```